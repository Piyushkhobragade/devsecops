Cloud-Native DevSecOps Pipeline with Policy-as-Code & FinOps GuardrailsA production-grade DevSecOps pipeline that enforces security, compliance, and cost controls before infrastructure and code reach AWS.What This Project SolvesThis repository contains a production-grade, security-first implementation for a secure-by-design software supply chain deploying a containerized Python application to AWS. The project adheres to strict DevSecOps and FinOps principles, enforcing compliance through Policy-as-Code (PaC) and immutable infrastructure patterns.Key capabilities include:Zero-Trust Authentication: GitHub Actions authenticates via AWS OIDC (OpenID Connect) Federation. No long-lived IAM keys are stored.Automated Governance: Custom Checkov policies block non-compliant infrastructure (e.g., untagged resources, expensive instance types) before provisioning.Shift-Left Security: Integrated scanning for secrets, SAST, SCA, and container vulnerabilities.Cost Control: Pre-deployment cost estimation and AWS Cost Anomaly detection.Architecture DecisionsDesign Philosophy: Security, cost, and compliance are enforced at CI time — not reviewed manually after deployment.The infrastructure is provisioned using Terraform and orchestrated by GitHub Actions.Compute: Amazon EC2 (Dockerized runtime)Networking: VPC, Public Subnet (Cost-optimized), Security GroupsObservability: CloudWatch Logs, Metrics, Alarms, SNSState Management: S3 Backend with DynamoDB LockingDesign Decision: The architecture targets the us-east-1 region and utilizes a public subnet architecture to eliminate NAT Gateway costs, strictly adhering to AWS Free Tier limits while maintaining full operational visibility.Secure Delivery PipelineThe deployment pipeline (.github/workflows/deploy.yml) enforces a strict quality gate:Security Analysis:TruffleHog: Blocks commit history containing high-entropy secrets.Bandit: Fails the pipeline on critical Static Application Security Testing (SAST) findings.Snyk/Trivy: Prevents merge if dependencies contain known critical CVEs.Artifact Generation:Builds Docker image.Trivy/Grype: Scans container layers for OS vulnerabilities.Infrastructure Validation:Infracost: Calculates cost impact of the Pull Request.Checkov: Blocks non-compliant Terraform before provisioning (CIS benchmarks + Custom Policies).Delivery:terraform apply updates the infrastructure state.Smoke tests validate the /health endpoint.Security ControlsAll controls are enforced automatically and fail the pipeline on violation — no manual approvals.Control LayerToolingEnforcement / OutcomeSecret DetectionTruffleHogPipeline Fails (Pre-commit/Pre-build block)Code SecurityBanditBuild Fails on High SeverityDependency SecuritySnyk / TrivyMerge Denied on Critical CVEsInfrastructure SecurityCheckov / tfsecDeployment Blocked on MisconfigurationContainer SecurityTrivyImage vulnerability scanningIdentityAWS OIDCFederated AuthenticationPolicy-as-Code (Custom Implementation)Governance is enforced via custom Python-based Checkov policies found in the policies/ directory. These policies act as hard gates, not advisory checks.CKV_AWS_CUSTOM_1: Enforces mandatory CostCenter tagging on all resources.CKV_AWS_CUSTOM_2: Restricts EC2 instances to t2.micro or t3.micro families.CKV_AWS_CUSTOM_3: Blocks SSH (Port 22) access from global 0.0.0.0/0 CIDRs.ObservabilityApplication and infrastructure health are monitored natively in AWS CloudWatch. Monitoring is designed for operational response, not vanity metrics.Operational Dashboard:Automated Alerting:Log Aggregation: Flask application logs and system logs are streamed to CloudWatch Log Groups.Metric Alarms: SNS notifications trigger if CPU utilization > 80% for 5 minutes.Cost Management (FinOps)This project demonstrates FinOps-aware DevOps, where cost is treated as a first-class constraint.Infracost: Runs in CI to predict monthly spend changes.AWS Cost Anomaly Detection: Monitors for spending spikes with a threshold of $1.00 USD.Resource Constraints: Policy-as-Code prevents the instantiation of non-Free-Tier resources.Verification1. Verify Infrastructure Stateterraform output public_ip
curl http://<output_ip>:5000/health
2. Production Health Check3. Run Security Policies Locallycheckov -d ./terraform --check CKV_AWS_CUSTOM_1 --external-checks-dir ./policies
Known LimitationsAvailability: Single-AZ deployment (US-EAST-1a) to minimize data transfer costs.Network: Public subnet placement avoids NAT Gateway charges but requires rigorous Security Group management.Secrets: Runtime secrets utilize Terraform user_data injection rather than AWS Secrets Manager to reduce API cost overhead.Roadmap (Planned Enhancements)TLS termination via Nginx reverse proxyGitOps-based CD with ArgoCDPrivate subnet isolation using NAT InstanceAuthor: Piyush Kho
